# Heap Sort - ヒープソート

## 概要
ヒープソートは**ヒープ**というデータ構造を使ったソートアルゴリズムです。最大ヒープを構築し、最大値を取り出す操作を繰り返します。

## ヒープとは
**ヒープ**は完全二分木で、以下の性質を持ちます：
- **最大ヒープ**: 親ノード >= 子ノード
- **配列で表現**: `left = 2*i + 1`, `right = 2*i + 2`, `parent = (i-1)/2`

```
配列: [22, 19, 5, 3]

ツリー表現:
       22        ← 最大値がルート
      /  \
    19    5
   /
  3
```

## アルゴリズムの動き
1. **ヒープ構築**: 配列を最大ヒープに変換
2. **ソート**: ルート（最大値）と最後の要素を交換し、ヒープサイズを縮小して再度ヒープ化

```
[3, 22, 19, 5] の場合

【ヒープ構築】
[3, 22, 19, 5] → heapify
[22, 5, 19, 3]    ← 最大ヒープ

【ソートフェーズ】
ステップ1: 22と3を交換
          [3, 5, 19 | 22]  ← 22確定
          heapify([3, 5, 19])
          [19, 5, 3 | 22]

ステップ2: 19と3を交換
          [3, 5 | 19, 22]  ← 19確定
          heapify([3, 5])
          [5, 3 | 19, 22]

ステップ3: 5と3を交換
          [3 | 5, 19, 22]  ← 5確定

結果: [3, 5, 19, 22]
```

## コードの解説

### ヒープ化処理（main.cpp:6-23）
```cpp
void heapify(vector<int> &nums, int size, int i)
{
    int largest = i;           // 親ノード
    int left = 2 * i + 1;      // 左の子
    int right = 2 * i + 2;     // 右の子

    // 左の子が親より大きいか
    if (left < size && nums[left] > nums[largest])
        largest = left;

    // 右の子が親より大きいか
    if (right < size && nums[right] > nums[largest])
        largest = right;

    // 親が最大でなければ交換して再帰
    if (largest != i)
    {
        swap(nums[i], nums[largest]);
        heapify(nums, size, largest);
    }
}
```

### ソート処理（main.cpp:25-39）
```cpp
void heapSort(vector<int> &nums)
{
    int size = nums.size();

    // 最大ヒープを構築（下から上へ）
    for (int i = size / 2 - 1; i >= 0; i--)
    {
        heapify(nums, size, i);
    }

    // ルートを取り出してソート
    for (int i = size - 1; i >= 0; i--)
    {
        swap(nums[0], nums[i]);     // 最大値を末尾へ
        heapify(nums, i, 0);        // 残りをヒープ化
    }
}
```

## 計算量
- **時間計算量**:
  - 最良: O(n log n)
  - 平均: O(n log n)
  - 最悪: O(n log n)
- **空間計算量**: O(1)（イン・プレース）

## 特徴
- **不安定ソート**: 同じ値の順序が保たれない
- **保証された性能**: 常にO(n log n)
- **イン・プレース**: 追加の配列が不要
- **クイックソートより遅い**: 平均的にはクイックソートの方が速い

## 使いどころ
- メモリが限られていて、かつO(n log n)を保証したい場合
- 優先度付きキュー（ヒープの応用）
- k番目に大きい/小さい要素を見つける問題

## 他のソートとの比較
- **クイックソート vs ヒープソート**:
  - クイックソート: 平均的に速いが、最悪O(n²)
  - ヒープソート: 常にO(n log n)だが、平均的にやや遅い
- **マージソート vs ヒープソート**:
  - マージソート: 安定、追加メモリ必要
  - ヒープソート: 不安定、イン・プレース
