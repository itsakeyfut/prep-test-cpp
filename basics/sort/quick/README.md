# Quick Sort - クイックソート

## 概要
クイックソートは**分割統治法**を用いた高速なソートアルゴリズムです。ピボット（基準値）を選び、それより小さい要素と大きい要素に分割して再帰的にソートします。

## アルゴリズムの動き
1. **ピボット選択**: 基準となる値を選ぶ（このコードでは最後の要素）
2. **分割**: ピボットより小さい要素を左、大きい要素を右に配置
3. **再帰**: 左右の部分配列に対して同じ処理を繰り返す

```
[3, 22, 19, 5] の場合（ピボット = 最後の要素）

初期: [3, 22, 19, 5]  ピボット=5

【分割】
3 <= 5 → 左へ
22 > 5 → 右へ
19 > 5 → 右へ
5と交換 → [3, 5, 19, 22]
           ↑
        ピボット位置確定

【再帰】
左: [3]      → 1要素なので完了
右: [19, 22] → ピボット=22で分割
              [19, 22] → 完了

結果: [3, 5, 19, 22]
```

## コードの解説

### 分割処理（main.cpp:6-22）
```cpp
int partition(vector<int> &nums, int low, int high)
{
    int pivot = nums[high];    // ピボット（最後の要素）
    int i = low - 1;           // 小さい要素の境界

    for (size_t j = low; j < high; ++j)
    {
        if (nums[j] <= pivot)  // ピボット以下なら
        {
            ++i;
            swap(nums[i], nums[j]);  // 左側に移動
        }
    }

    swap(nums[i + 1], nums[high]);  // ピボットを正しい位置に
    return i + 1;                   // ピボットの位置を返す
}
```

### 再帰処理（main.cpp:24-32）
```cpp
void quickSort(vector<int> &nums, int low, int high)
{
    if (low < high)
    {
        int pi = partition(nums, low, high);  // 分割してピボット位置取得
        quickSort(nums, low, pi - 1);         // 左半分を再帰的にソート
        quickSort(nums, pi + 1, high);        // 右半分を再帰的にソート
    }
}
```

## 計算量
- **時間計算量**:
  - 最良: O(n log n)
  - 平均: O(n log n)
  - 最悪: O(n²)（既にソート済みで、最悪のピボット選択の場合）
- **空間計算量**: O(log n)（再帰スタック）

## 特徴
- **不安定ソート**: 同じ値の順序が保たれない可能性がある
- **平均的に最速**: 実用的には最も高速なソートアルゴリズムの一つ
- **イン・プレース**: 追加の配列が不要（マージソートより省メモリ）
- **ピボット選択が重要**: 選び方で性能が変わる

## ピボット選択の改善
このコードでは最後の要素をピボットにしていますが、以下の改善方法があります：

1. **ランダム**: ランダムに選ぶ → 最悪ケースを回避
2. **中央値**: 先頭・中央・末尾の3つの中央値 → バランスの良い分割
3. **3-way partition**: 同じ値が多い場合に有効

## 使いどころ
- 一般的なソート用途（最も広く使われる）
- 大量のデータ
- メモリが限られている場合
- 平均的なケースで最高の性能が欲しい場合

## 他のソートとの比較
- **クイックソート vs マージソート**:
  - クイックソート: 平均的に速い、省メモリ、最悪O(n²)、不安定
  - マージソート: 常にO(n log n)、安定、追加メモリが必要
